NOTES:
- SHIFT + K over a symbol to see its manual
- Plan, Design, then Develop

PLAN:
  GAME FLOW:
  - initialize data in main function (start/init)
  - parse ommand line arguments
  - start ncurses
  - while the game loop is running
    - update graphics   (render)
    - handle user move  (input)
    - get opponent move (input, network)
    - update game state (update, network)
  - end ncurses

DESIGN:
  FUNCTIONS:
  - pass pointers to structs and other data entities
  - functions of form 'int f(A in, B *out)'
  - data-oriented design, structs capture game state and types, references to data types are passed around and modified by functions they're passed to
  GRAPHICS:
  - graphics functions should have windows passed in, along with whatever data refs needed.
  - instead of numbers representing map state and then chars representing that (indirect), chars are instead directly embedded into the map to both repesent its state and its view at once
  DATA:
  - following a DOD approach, a single struct of structs will capture the gamestate in static memory
  - structs will be packed to reduce memory footprint. The goal is to fit this in 14kb or less
  - the map represents player board state, and known enemy board state.
  - the map is inextricably tied to the pins and ships structs, representing shot tiles and ship data respectively.
  GENERAL:
  - initial data structures like intial board position and the like will be initialized at compile time as global variables and macros



TODO:
- rendering the main game screen should update once to start, then
  - update log whenever an interaction is occuring
  - show tooltips below log window when necessary
  - update radars
    - once per enemy action for player radar
      - then local ships
      - then enemy pins
    - every player interaction for enemy radar
      - then placing pins to display information
- place ships and attack tiles
  - place ship function
    - one ship at a time
    - should use render ship (not ships) to display that information
    - render ship will render underlying water of map first
  - attack tiles function
    - checks if selection is in pins, updates pos and adds to pins if it isn't
  OVERVIEW:
    - ship and pin structs will record gameplay elements, map isn't needed since queries on ship and tile location can be resolved effectively by looking through every ship (only 5 of them) and checking if local pins have been tried or not.
    - rendering the map then will consist of painting layers (water first, then ships, then pins)

- implement networking
  - client
  - server
  - peer-to-peer connection (basic netcat-like)
  - automatic search for nearby partners (lan searching)
  - singleplayer functionality (connect to second local instance, basically echo with randomness)
  - multiplaye functionality (turn-based send-recv loop, negotiate initial connection with MAIN and PEER)
- write a function to quickly calculate if a coordinate overlaps with a ship and which ship it overlaps with (pointer magic?)
- implement game loop
  - place ships
    - handle input (input function)
    - verify ships are not overlapping or out of bounds
    - store ship positions in ship structs
  - mark ships on player map
  - attack loop
    - handle input (input function)
    - verify tile on enemy side is a ship or not
    - update info on enemy local map and player local map
    - switch turns (how to record this?)
